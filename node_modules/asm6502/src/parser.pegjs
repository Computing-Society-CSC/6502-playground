start = line*
line = _* @node|1.., _| _* '\n'? _*
node = label / instruction / directive / expression / comment / '\n'

instruction = immediateInstruction / indirectXInstruction
  / indirectYInstruction / indirectInstruction / genericInstruction

genericInstruction = o:opcode a:(_ @argument)? {
  return {instruction: {opcode: o, arg: a}}
}

immediateInstruction = o:opcode _ '#' a:argument {
  return {instruction: {mode: 'immediate', opcode: o, arg: a}}
}

indirectInstruction = o:opcode _ '(' a:argument ')' {
  return {instruction: {mode: 'indirect', opcode: o, arg: a}}
}

indirectXInstruction = o:opcode _ a:('(' @(number / name) ',' _? [x] ')') {
  return {instruction: {mode: 'indirectX', opcode: o, arg: a}}
}

indirectYInstruction = o:opcode _ a:('(' @(number / name) ')' ',' _? [y]) {
  return {instruction: {mode: 'indirectY', opcode: o, arg: a}}
}

directive = d:('.' name) _? a:argumentlist? {
  return {directive: d.join(''), args: a}
}

expression = l:(number/ name) _? o:operator _?
  r:(expression / number / name) {
    return {expression: {operator: o, left: l, right: r}}
}

operator = [+=\*]
comment = ';'+ c:[^\n]* { return {comment: c.join('')} }
argument = indexedArg / expression / @(number / name / string)
indexedArg = @(expression / number / name) ',' _? @[xy]
argumentlist = @argument|.., argdelimiter|
label = n:name ":" { return {label: n} }
name = s:[@A-Z0-9_]i+ { return  s.join('') }
string = '"' s:[^"]* '"' { return s.join('') }
number = hexnumber / binarynumber / decimalnumber
binarynumber = '%' n:[0-1]+ {return parseInt(n.join(''), 2) }
decimalnumber = n:[0-9]+ {return parseInt(n.join('')) }
hexnumber = '$' n:[0-9A-F]i+  {return parseInt(n.join(''), 16) }
_ = [ \t]+
argdelimiter = ',' _?

opcode = o:("ADC"i / "AND"i / "ASL"i / "BCC"i / "BCS"i
  / "BEQ"i / "BIT"i / "BMI"i / "BNE"i / "BPL"i / "BRA"i
  / "BRK"i / "BVC"i / "BVS"i / "CLC"i / "CLD"i / "CLI"i
  / "CLV"i / "CMP"i / "CPX"i / "CPY"i / "DEC"i / "DEX"i
  / "DEY"i / "EOR"i / "INC"i / "INX"i / "INY"i / "JMP"i
  / "JSR"i / "LDA"i / "LDY"i / "LDX"i / "LSR"i / "NOP"i
  / "ORA"i / "PHA"i / "PHX"i / "PHY"i / "PHP"i / "PLA"i
  / "PLP"i / "PLY"i / "ROL"i / "ROR"i / "RTI"i / "RTS"i
  / "SBC"i / "SEC"i / "SED"i / "SEI"i / "STA"i / "STX"i
  / "STY"i / "STZ"i / "TAX"i / "TAY"i / "TSX"i / "TXA"i
  / "TXS"i / "TYA"i)
